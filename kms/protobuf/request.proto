// Copyright 2023 - MinIO, Inc. All rights reserved.
// Use of this source code is governed by the AGPLv3
// license that can be found in the LICENSE file.

// Generate the Go protobuf code by running the protobuf compiler
// from the repository root:
//
//   $ protoc -I=./kms/protobuf --go_out=. ./kms/protobuf/*.proto

syntax = "proto3";

package minio.kms;

option go_package = "kms/protobuf";

message EditClusterRequest {
  // RemoveIDs is a list of KMS server IDs that are removed from
  // the cluster definition of the KMS server that receives the
  // request.
  repeated uint32 RemoveIDs = 1 [ json_name = "remove" ];
}

message CreateKeyRequest {
  // Type is the type of the created key. If not set, the KMS server picks
  // a key type.
  optional string Type = 1 [ json_name = "type" ];

  // AddVersion indicates whether a new key version is created.
  bool AddVersion = 2 [ json_name = "add_version" ];
}

message DeleteKeyRequest {
  // Version identifies the key version within the key ring to remove.
  // If zero, the latest key version is removed.
  uint32 Version = 1 [ json_name = "version" ];

  // AllVersions indicates whether all key versions should be removed.
  bool AllVersions = 2 [ json_name = "all_versions" ];
}

message EncryptRequest {
  // Version identifies the key version within the key ring used to encrypt
  // the plaintext. If zero, the latest key version is used.
  uint32 Version = 1 [ json_name = "version" ];

  // Plaintext is the plain message that is encrypted.
  bytes Plaintext = 2 [ json_name = "plaintext" ];

  // AssociatedData is additional data that is not encrypted but crypto. bound
  // to the ciphertext. The same associated data must be provided when decrypting
  // the ciphertext.
  //
  // Associated data should describe the context of the plaintext data. For example,
  // the name of the file that gets encrypted.
  bytes AssociatedData = 3 [ json_name = "associated_data" ];
}

message GenerateKeyRequest {
  // Version identifies the key version within the key ring used to generate
  // the data encryption key. If zero, the latest key version is used.
  uint32 Version = 1 [ json_name = "version" ];

  // AssociatedData is additional data that is not encrypted but crypto. bound
  // to the ciphertext of the data encryption key. The same associated data must
  // be provided when decrypting the ciphertext.
  //
  // Associated data should describe the context within the data encryption key
  // is used. For example, the name of the file that gets encrypted with the
  // data encryption key.
  bytes AssociatedData = 2 [ json_name = "associated_data" ];

  // Length is the length of the generated plaintext data encryption key in bytes.
  // At most 1024 (8192 bits). If not present, defaults to 32 (256 bits).
  optional uint32 Length = 3 [ json_name = "length"];
}

message DecryptRequest {
  // Version identifies the key version within the key ring that should be
  // used to decrypt the ciphertext. Must not be zero.
  uint32 Version = 1 [ json_name = "version" ];

  // Ciphertext is the encrypted message that gets decrypted.
  bytes Ciphertext = 2 [ json_name = "ciphertext" ];

  // AssociatedData is additional data that has been crypto. bound to the
  // ciphertext.
  bytes AssociatedData = 3 [ json_name = "associated_data" ];
}

message CreatePolicyRequest {
  map<string, string> Allow = 1 [ json_name = "allow" ];
  map<string, string> Deny = 2 [ json_name = "deny" ];
}

message CreateIdentityRequest {
  // Privilege is the privilege the identity has. Either, "SysAdmin", "Admin" or
  // "User".
  string Privilege = 1 [ json_name = "privilege" ];

  // IsServiceAccount indicates whether the identity is a service account.
  bool IsServiceAccount = 2 [ json_name = "service_account" ];
}
